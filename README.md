# GameDemo
这是闲暇时间写了一些开头的一个RPG游戏Demo，主要目的是练手学习。

大致记录一下值得思考的地方：


# 1、地图
本质上2D游戏中的所有一切图像都是贴图，地图也不例外，读取美术资源，在最低的层次Draw出来即可。

问题一：地图会随着角色的移动而移动(不是移动到边界才移动视角)，需要频繁地重新读入地图数据。但从硬盘（美术资源）读入数据需要时间，如果每次在角色移动需要重新刷新地图数据时才从硬盘读入，会造成较长时间的卡顿。

解决办法自然会想到预加载。假设整个地图尺寸达到10500*8100，完全加载到内存需要324MB，显然不可接受。于是可以分成N张小地图，每次预加载直读取小地图。但这样会遇到第二个问题。

问题二：如何切分资源才能达到高利用率又不卡顿？

假设我们切分每张地图块大小等同于游戏窗口大小，但由于角色每次移动均需要移动视角，此时不会留下任何时间去预加载另一块小地图，这就变成了直接从硬盘读取某一块小地图，同样会带来卡顿。所以我们需要足够的预加载时间。
为达到这个目的，需要每次将一个略大于游戏窗口的地图资源加载到内存中，移动角色时由于短时间内不会移动出当前内存中地图资源的范围，可以在这个短时间内对玩家移动方向进行判断，并在另一个buffer中对即将移动到的另一块地图资源进行预加载(独立于玩家操作的线程)。一旦加载成功，交换两个buffer的指针即可。

综上所述，我们需要两个buffer来进行地图资源的预加载，且每一个buffer的尺寸要略大于游戏窗口尺寸，大的这个值就作为玩家移动靠近边界的临界值，一旦达到临界范围，开始在另一条线程预加载备用buffer，完成后交换buffer指针。注意临界值的大小需要足够玩家到达当前资源边界之前读取成功。

 ![image](https://github.com/qinyuxiong/GameDemo/raw/master/ReadMe/1.jpg)
 
假设以分辨率1366×768 来说，一张能够填满窗口的图载入到内存需要约1MB。进行预加载，假设内存中地图资源buffer尺寸为1750*900，占用约1.5MB内存，两个buffer总共3MB内存，能够接受。

 ![image](https://github.com/qinyuxiong/GameDemo/raw/master/ReadMe/4.jpg)

# 2、控件
游戏中的对话框基本等同于全部UI，一个对话框可能包含N个控件，如：输入框、文本、按钮、列表等。

以空白Widget控件为基类，可继承出输入框、文本、按钮、列表等。空白控件包含所有控件都有的基本属性如坐标点、长、宽、背景图、控件名等。在子类中添加各种控件需要的属性，如输入框需要记录输入的文字、闪烁的光标等。

对于控件的绘制，在空白控件基类中根据当前控件坐标绘制出一张背景图。子类控件在Draw时，先调用Widget::Draw，在做子类需要的绘制即可。
一个对话框可作为控件的容器存在，每个容器对应一个Layer，在对话框的Draw中，依据Layer从下往上画(最原始的画家算法，可进一步根据判断每个像素点的坐标可能在哪些控件区域内，直接绘制层次最高的控件，即可避免一个像素多次被绘制)。

对话框需要响应输入事件，在GameMgr捕捉到输入时间后，根据对话框层次，从上往下遍历。在每一个对话框里，根据Layer，从上往下遍历，判断当前时间是否发生在子控件内，以及该子控件是否能响应这个事件，如果是，则调用。

![image](https://github.com/qinyuxiong/GameDemo/raw/master/ReadMe/3.jpg)

# 3、动画
本质上动画是由一帧一帧的图像构成，即N张图片。然后以在每隔一段时间后播放下一张图片，如此循环，便是动画。

在指定位置Draw时，获取当前时间，如果与上次Draw的时间差大于一定值，则Draw下一张图片。时间差值由图片的帧率决定。此处注意图片帧率如果大于游戏帧率会看起来跳帧。

![image](https://github.com/qinyuxiong/GameDemo/raw/master/ReadMe/2.jpg)

# 4、其他
地图、控件、动画所需的如长度、资源路径等可存放在配置表文件中，读取时依据类别读取配置表。

每个需要绘制的控件或地图等，都需要一个Draw函数，在Canvas的surface之上进行绘制。Canvas可用两个surface作为双缓冲的实现。

每一帧有对话框管理器、地图管理器，依层次调用Draw，达到顺序绘制的目的。

# 5、目前存在的问题

1. 当初抱着学习的目的来写这个demo，希望能够从中找到从0开始写一个RPG游戏的感觉。目前简单的实现一些基本结构，对话框能够根据配置表形成，地图能够较流畅地移动且不占用过多资源。因为完全手动实现，所以很多基础的功能都要从头开始写，比如读取BMP图像、多张图像数据的拼接、在图像指定区域绘制等。基础功能的实现需要细致与耐心，会花掉不少的时间，也会分散投入到写逻辑中的精力。实际上比较费力不讨好，开发起来也慢。这也是主要困难所在。无法尽快实现想要的效果，需要手写底层支持，会让我渐渐失去兴趣。


1. 虽然控件、地图都能够自己写入到Buffer中直接Blit到设备显示，但文字的处理就只有用GDI了，这就带来了目前存在的刷新不及时，文字闪烁严重的问题。如果不用三方库，可能不好解决。



1. 代码都是为了实现效果写出来的，可能目前会存在许多漏洞，不够Robust。这些需要以后花时间修改。毕竟《游戏编程模式》告诉过，”首先实现、再优化“这个道理。

